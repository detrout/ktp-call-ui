// Autogenerated by the QtGStreamer helper code generator - DO NOT EDIT
/*
    Copyright (C) 2010 George Kiagiadakis <kiagiadakis.george@gmail.com>
    Copyright (C) 2010 Collabora Ltd.
      @author George Kiagiadakis <george.kiagiadakis@collabora.co.uk>

    This library is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published
    by the Free Software Foundation; either version 2.1 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#define INCLUDED_FROM_CODEGEN
#include <boost/static_assert.hpp>

#define REGISTER_TYPE_IMPLEMENTATION(T, GTYPE) \
    namespace QGlib { \
        GetTypeImpl<T>::operator Type() { return (GTYPE); } \
    }

#include </usr/include/farstream-0.2/farstream/fs-candidate.h>
#include </usr/include/farstream-0.2/farstream/fs-codec.h>
#include </usr/include/farstream-0.2/farstream/fs-conference.h>
#include </usr/include/farstream-0.2/farstream/fs-participant.h>
#include </usr/include/farstream-0.2/farstream/fs-session.h>
#include </usr/include/farstream-0.2/farstream/fs-stream.h>
#include "candidate.h"

REGISTER_TYPE_IMPLEMENTATION(QFs::Candidate,FS_TYPE_CANDIDATE)

namespace QFs {
  QGlib::RefCountedObject *Candidate_new(void *instance)
  {
    QFs::Candidate *cppClass = new QFs::Candidate;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QFs

#include "codec.h"

REGISTER_TYPE_IMPLEMENTATION(QFs::Codec,FS_TYPE_CODEC)

namespace QFs {
  QGlib::RefCountedObject *Codec_new(void *instance)
  {
    QFs::Codec *cppClass = new QFs::Codec;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QFs

#include "conference.h"

REGISTER_TYPE_IMPLEMENTATION(QFs::Conference,FS_TYPE_CONFERENCE)

namespace QFs {
  QGlib::RefCountedObject *Conference_new(void *instance)
  {
    QFs::Conference *cppClass = new QFs::Conference;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QFs

#include "participant.h"

REGISTER_TYPE_IMPLEMENTATION(QFs::Participant,FS_TYPE_PARTICIPANT)

namespace QFs {
  QGlib::RefCountedObject *Participant_new(void *instance)
  {
    QFs::Participant *cppClass = new QFs::Participant;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QFs

#include "session.h"

REGISTER_TYPE_IMPLEMENTATION(QFs::Session,FS_TYPE_SESSION)

namespace QFs {
  QGlib::RefCountedObject *Session_new(void *instance)
  {
    QFs::Session *cppClass = new QFs::Session;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QFs

#include "stream.h"

REGISTER_TYPE_IMPLEMENTATION(QFs::Stream,FS_TYPE_STREAM)

namespace QFs {
  QGlib::RefCountedObject *Stream_new(void *instance)
  {
    QFs::Stream *cppClass = new QFs::Stream;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QFs

#include "enums.h"

REGISTER_TYPE_IMPLEMENTATION(QFs::MediaType,FS_TYPE_MEDIA_TYPE)

namespace QFs {
    BOOST_STATIC_ASSERT(static_cast<int>(MediaTypeAudio) == static_cast<int>(FS_MEDIA_TYPE_AUDIO));
    BOOST_STATIC_ASSERT(static_cast<int>(MediaTypeVideo) == static_cast<int>(FS_MEDIA_TYPE_VIDEO));
    BOOST_STATIC_ASSERT(static_cast<int>(MediaTypeLast) == static_cast<int>(FS_MEDIA_TYPE_LAST));
}

namespace QFs {
namespace Private {
  void registerWrapperConstructors()
  {
    QGlib::Quark q = g_quark_from_static_string("QGlib__wrapper_constructor");
    QGlib::GetType<Candidate>().setQuarkData(q, reinterpret_cast<void*>(&Candidate_new));
    QGlib::GetType<Codec>().setQuarkData(q, reinterpret_cast<void*>(&Codec_new));
    QGlib::GetType<Conference>().setQuarkData(q, reinterpret_cast<void*>(&Conference_new));
    QGlib::GetType<Participant>().setQuarkData(q, reinterpret_cast<void*>(&Participant_new));
    QGlib::GetType<Session>().setQuarkData(q, reinterpret_cast<void*>(&Session_new));
    QGlib::GetType<Stream>().setQuarkData(q, reinterpret_cast<void*>(&Stream_new));
  }
} //namespace Private
} //namespace QFs

